<!DOCTYPE html>
<html>
<head>

<meta http-equiv="content-type" content="text/html;charset=UTF-8" />
<title>mousetrack</title>

<script type="text/x-mathjax-config">
  contents = '';

  MathJax.Hub.Config({
    TeX: {
      Macros: {
        mymatrix: ['{\\begin{bmatrix} #1 \\end{bmatrix}}',1],
        del: ['\\partial',0],
        by: ['\\over',0]
      },
      equationNumbers: {
        autoNumber: "all"
      }
    },
  });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_SVG">
</script>

<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

<style type="text/css">

body {
  background-color: #ffffff;
  font-family: Georgia, serif;
  width: 50em;
  margin-left: auto;
  margin-right: auto;
}

h1 {
  font-family: 'Roboto', sans-serif;
  color: #6aa84f;
  text-align: center;
  font-size: 300%;
}

.subtitle {
  font-family: 'Roboto', sans-serif;
  color: #6aa84f;
  text-align: center;
  font-size: 150%;
}

.author {
  font-family: 'Trebuchet MS', Helvetica, sans-serif;
  color: #808080;
  text-align: center;
  font-size: 150%;
}

h2 {
  font-family: 'Trebuchet MS', Helvetica, sans-serif;
  color: #6aa84f;
  text-indent: -70px;
  position: relative;   /* Needed so h2 .marker position works */
}

h2 .marker {
  background-color: #6aa84f;
  position: absolute;
  top: 0.2em;
  left: -140px;
  width: 50px;
  height: 0.8em;
  border-style: none;
}

h3 {
  font-family: 'Trebuchet MS', Helvetica, sans-serif;
  color: #6aa84f;
  text-indent: -35px;
}

h4 {
  font-family: 'Trebuchet MS', Helvetica, sans-serif;
  color: #6aa84f;
}

table {
  border-collapse: collapse;
  padding: 0px;
}

table td {
  border: 1px solid #c0c0c0;
  vertical-align: top;
}

table td p {
  margin: 5px 5px;
}

pre {
  color: #0000ff;
  /* background-color: #e0ffff; */
  padding: 2px;
  font-size: 110%;
}

li p {
  margin: 0px 0px;
}

tt {
  color: #0000ff;
  font-size: 110%;
}

.contents_line_H2 {
  margin-left: 30px;
}

.contents_line_H3 {
  margin-left: 60px;
}

.contents_line_H4 {
  margin-left: 90px;
}

</style>

</head>
<body>

<!-- Main body of document inserted here -->
<script type='text/javascript'>__the_title__='Mousetrack'</script><h1 id='title'></h1>
<h1 class='author'>jq</h1>
<div class='contents' id='contents'></div>
<h2 class='section_entry' id='1.'><span class='marker'></span>1. Kalman Filter</h2>
<p>Apply Kalman Filter for a single track. For long-range autonomous driving tracking problems, we can assume a 2D tracking space, where there is no need for z or elevation information.</p>
<h3 class='section_entry' id='1.1.'>1.1. General problem statement</h3>
<p>The state is modeled by </p>
\[\begin{align}s(k+1) = As(k) + w(k) + f(k+1|k)\end{align}\]
<p>where \(w(k)\) represents the process noise, estimated by a Gaussian \(\mathcal{N}(0, Q)\), and \(f(k+1|k)\) denotes a deterministic input such as relative position change due to own-ship motion.</p>
<p>Measurements are modeled by </p>
\[\begin{align}m(k) = Cs(k) + v(k)\end{align}\]
<p>where \(v(k)\) is the measurement noise, estimated by a Gaussian \(\mathcal{N}(0, R)\).</p>
<p>We want to estimate the belief function of \(s\), </p>
\[\begin{align}\beta(s_k) = \mathcal{N}(\mu_k, \Sigma_k, s_k)\end{align}\]
<p>From the previous belief function \(\beta(s_{k-1})\), we expect the unfiltered estimation of the current state is described by </p>
\[\begin{align}\hat{\mu}(k|k-1) = A\mu(k-1)\end{align}\]
\[\begin{align}\hat{\Sigma}(k|k-1) = A\Sigma(k-1)A^T + Q\end{align}\]
<p>The Kalman gain is </p>
\[\begin{align}\label{eq:kf_gain} K(k) = \hat{\Sigma}(k|k-1)C^T[C\hat{\Sigma}(k|k-1)C^T + R]^{-1}\end{align}\]
<p>The filtered state is </p>
\[\begin{align}\mu(k|k) = \hat{\mu}(k|k-1) + K(k)\tilde{m}(k)\end{align}\]
\[\begin{align}\label{eq:kf_cov} \Sigma(k|k) = [\mathcal{I} - K(k)C] \hat{\Sigma}(k|k-1)\end{align}\]
<p>where \(\tilde{m} = m(k) - C\hat{\mu}(k|k-1)\) is the unfiltered measurement residual, i.e. the innovation, and its covariance is \(S(k) = C\hat{\Sigma}(k|k-1)C^T + R\).</p>
<p>Finally, future state predictions are given by </p>
\[\begin{align}\mu(k+1|k) = A\mu(k|k)\end{align}\]
\[\begin{align}\Sigma(k+1|k) = A\Sigma(k|k)A^T + Q\end{align}\]
<h3 class='section_entry' id='1.2.'>1.2. Evaluate filter performance</h3>
<h3 class='section_entry' id='model1'>1.3.  Model 1. Nonlinear measurement matrix \(C\), Taylor expansion for measurement noise covariance \(R\)</h3>
<p>Radar measurements are in polar coordinates. We choose to track in cartesian coordinates for a more intuitive model of target motion. For a radar scan interval of time \(T\), target motions are simply </p>
\[\begin{align}
x(k+1) = x(k) + T\dot{x}(k) + \frac{T^2}{2}\ddot{x}(k) \nonumber \\
y(k+1) = y(k) + T\dot{y}(k) + \frac{T^2}{2}\ddot{y}(k) \label{eq:kinetics}
\end{align}\]
<p>The state update model is </p>
\[\begin{align} \label{eq:const_v_process}
s = \begin{bmatrix} x \\ \dot{x} \\ y \\ \dot{y} \end{bmatrix},\quad
A = \begin{bmatrix} 1 &amp; T &amp; 0 &amp; 0 \\
                    0 &amp; 1 &amp; 0 &amp; 0 \\
		    0 &amp; 0 &amp; 1 &amp; T \\
		    0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}
\end{align}\]
<p>The measurement model that bridges polar to cartesian coordinates is </p>
\[\begin{align}
m(k) &amp;= Cs(k) \nonumber \\
\begin{bmatrix} x \\ y \\ r\dot{r} \end{bmatrix} = \begin{bmatrix} -r \sin(\theta) \\ r \cos(\theta) \\ r\dot{r} \end{bmatrix} &amp;=
\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\
		0 &amp; 0 &amp; 1 &amp; 0 \\
		\dot{x} &amp; x &amp; \dot{y} &amp; y
\end{bmatrix}
\begin{bmatrix} x \\ \dot{x} \\ y \\ \dot{y} \end{bmatrix}
\end{align}\]
<p>TODO: the form of \(m = Cs\) comes from [Radar Data Processing by Farina and Studer, Section 4.6], derive, and alternative treatments, e.g. EKF or UKF?</p>
<p>Notes: </p>
<ul>
<li><p>Acceleration is not included in the state model for now. </p>

</ul>
<h4 class='section_entry' id='1.3.1.'>1.3.1. Process covariance</h4>
<p>Process noise may include white noise from e.g. the RF mixer, correlated noise e.g. angular scintillation, and as a way to treat target acceleration or maneuvering using the Singer model. For now, we use the Singer model for slowly maneuvering targets, that is, sampling time \(T \ll \tau_m\) the maneuver time constant. The resulting covariance is stated here without derivation, adapted from [Blackman book, Page 33].</p>
<p>TODO: derive, model other noise</p>
\[\begin{align}
Q = \frac{2\sigma^2_m}{\tau_m}
\begin{bmatrix}
\frac{T^5}{20} &amp; \frac{T^4}{8} &amp; 0 &amp; 0 \\
\frac{T^4}{8} &amp; \frac{T^3}{3} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{T^5}{20} &amp; \frac{T^4}{8} \\
0 &amp; 0 &amp; \frac{T^4}{8} &amp; \frac{T^3}{3}
\end{bmatrix}
\end{align}\]
<h4 class='section_entry' id='1.3.2.'>1.3.2. Coordinate transform for measurement covariance</h4>
<p>Radar measurements typically consists of \(\{r, \dot{r}, \theta\}\) with variances \(\{\sigma^2_r, \sigma^2_{\dot{r}}, \sigma^2_\theta\}\). We wish to calculate the covariance of the measurement noise \(\mathcal{N}(0, R)\), where </p>
\[\begin{align}R =
\begin{bmatrix}
\sigma^2_{xx} &amp; \sigma^2_{xy} &amp; \sigma^2_{xr\dot{r}} \\
\sigma^2_{xy} &amp;  \sigma^2_{yy} &amp; \sigma^2_{yr\dot{r}} \\
\sigma^2_{xr\dot{r}} &amp; \sigma^2_{yr\dot{r}} &amp; \sigma^2_{r\dot{r}r\dot{r}}
\end{bmatrix}\end{align}\]
<p>is a function of the raw radar measurements' variances.</p>
<p>Consider a general transformation of a random variable \(\mathbf{x}\), with mean \(\bar{\mathbf{x}}\) and covariance \(\mathbf{\Sigma_x}\), to a new random variable \(\mathbf{y}\) by the nonlinear function \(f\) </p>
\[\begin{align}\mathbf{y} = f(\mathbf{x})\end{align}\]
<p>We apply Taylor expansion around \(\bar{\mathbf{x}}\), using subscript-summation notation, </p>
\[\begin{align}
f_i(\mathbf{x}) &amp;= f_i(\bar{\mathbf{x}}) + \frac{\partial f_i}{\partial x_j}(x_j-\bar{x}_j) + \frac{1}{2}\frac{\partial^2f_i}{\partial x_j \partial x_k}(x_j - \bar{x}_j)(x_k - \bar{x}_k) \nonumber \\
&amp;= f_i(\bar{\mathbf{x}}) + \mathbf{J}_i(\mathbf{x} - \bar{\mathbf{x}}) + \frac{1}{2}(\mathbf{x} - \bar{\mathbf{x}})^T\mathbf{H}_i(\mathbf{x} - \bar{\mathbf{x}})
\end{align}\]
<p>where \(\mathbf{J}_i\) is the i-th row of the Jacobian matrix, and \(\mathbf{H}_i\) is the i-th plane of the 3-dimensional Hessian tensor. Assume that \((\mathbf{x} - \bar{\mathbf{x}})\) is zero-mean with covariance \(\mathbf{\Sigma_x}\), take the expectation value to get \(\bar{\mathbf{y}}\) and \(\mathbf{\Sigma_y}\) </p>
\[\begin{align}
\bar{\mathbf{y}} = E(\mathbf{y}) &amp;= E(f(\bar{\mathbf{x}})) + \mathbf{J} E(\mathbf{x} - \bar{\mathbf{x}}) + \frac{1}{2}E((\mathbf{x} - \bar{\mathbf{x}})^T\mathbf{H}(\mathbf{x} - \bar{\mathbf{x}})) \nonumber \\
&amp;= f(\bar{\mathbf{x}}) + \frac{1}{2}E((\mathbf{x} - \bar{\mathbf{x}})^T\mathbf{H}(\mathbf{x} - \bar{\mathbf{x}})) \nonumber \\
&amp;\approx f(\bar{\mathbf{x}})
\end{align}\]
\[\begin{align}
\mathbf{\Sigma_y} = E((\mathbf{y} - \bar{\mathbf{y}})(\mathbf{y} - \bar{\mathbf{y}})^T) &amp;= \mathbf{J}E((\mathbf{x} - \bar{\mathbf{x}})(\mathbf{x} - \bar{\mathbf{x}})^T)\mathbf{J}^T \nonumber \\
&amp;= \mathbf{J}\mathbf{\Sigma_x}\mathbf{J}^T \label{eq:y_var}
\end{align}\]
<p>Apply \eqref{eq:y_var} to the measurement model, we have \(\mathbf{x} = \{r, \theta, \dot{r}\}\), \(f(\mathbf{x}) = \{-r\sin\theta, r\cos\theta, r\dot{r}\}\), assume the variances of \(\{r, \dot{r}, \theta\}\) are not correlated, </p>
\[\begin{align}
R &amp;= \mathbf{J}
\begin{bmatrix}
\sigma^2_r &amp; 0 &amp; 0 \\
0 &amp; \sigma^2_\theta &amp; 0 \\
0 &amp; 0 &amp; \sigma^2_\dot{r}
\end{bmatrix} \mathbf{J}^T \nonumber \\
&amp;= \begin{bmatrix}
\sigma^2_r\sin^2\theta + r^2\sigma^2_\theta\cos^2\theta &amp; \cos\theta\sin\theta(\sigma^2_r - r^2\sigma^2_\theta) &amp; -\dot{r}\sigma^2_r\sin\theta \\
\cos\theta\sin\theta(\sigma^2_r - r^2\sigma^2_\theta) &amp; r^2\sigma^2_\theta\sin^2\theta + \sigma^2_r\cos^2\theta &amp; \dot{r}\sigma^2_r\cos\theta \\
-\dot{r}\sigma^2_r\sin\theta &amp; \dot{r}\sigma^2_r\cos\theta &amp; \dot{r}^2\sigma^2_r + r^2\sigma^2_\dot{r}
\end{bmatrix}
\end{align}\]
<h3 class='section_entry' id='model2'>1.4.  Model 2. Nonlinear measurement model \(m = c(s)\), extended Kalman filter for belief covariance update \(C\hat{\Sigma}C^T\)</h3>
<p>The process model is unchanged from <a href='#model1'>Model 1</a> above, described by \eqref{eq:kinetics} and \eqref{eq:const_v_process}. The measurement vector is the radar's direct measurement, </p>
\[\begin{align}m(k) &amp;= c(s(k)) \nonumber \\
\begin{bmatrix}r \\ \theta \\ \dot{r}\end{bmatrix} &amp;=
\begin{bmatrix}
\sqrt{x^2 + y^2} \\
\arctan{(-x/y)} \\
-\dot{x}\sin{\theta} + \dot{y}\cos{\theta}
\end{bmatrix} \label{eq:c_fxn}\end{align}\]
<p>The measurement noise covariance is </p>
\[\begin{align}
R = \begin{bmatrix}
\sigma^2_r &amp; 0 &amp; 0 \\
0 &amp; \sigma^2_\theta &amp; 0
\\ 0 &amp; 0 &amp; \sigma^2_\dot{r}
\end{bmatrix}\end{align}\]
<p>Because we no longer have a matrix \(C\) to transform the state vector \(s\) to the measurement \(m\), calculations of the Kalman gain \eqref{eq:kf_gain} and the belief function covariance \eqref{eq:kf_cov} is now given by </p>
\[\begin{align}K(k) = \hat{\Sigma}(k|k-1)\mathbf{J}_c^T[\mathbf{J}_c\hat{\Sigma}(k|k-1)\mathbf{J}_c^T + R]^{-1}\end{align}\]
\[\begin{align}\Sigma(k|k) = [\mathcal{I} - K(k)\mathbf{J}_c] \hat{\Sigma}(k|k-1)\end{align}\]
<p>where </p>
\[\begin{align}
\mathbf{J}_c &amp;= \frac{\partial c(s)}{\partial s} \nonumber \\
 &amp;= \begin{bmatrix}
 \frac{x}{\sqrt{x^2+y^2}} &amp; 0 &amp; \frac{y}{\sqrt{x^2+y^2}} &amp; 0 \\
 -\frac{1}{(1+\frac{x^2}{y^2})y} &amp; 0 &amp; \frac{x}{(1+\frac{x^2}{y^2})y^2} &amp; 0 \\
 -\frac{x^2\dot{x}}{(1+\frac{x^3}{y^2})^{3/2}y^3} + \frac{\dot{x}}{\sqrt{1+\frac{x^2}{y^2}}y} - \frac{x\dot{y}}{(1+\frac{x^3}{y^2})^{3/2}y^2} &amp;
 \frac{x}{\sqrt{1+\frac{x^2}{y^2}}y} &amp;
 \frac{x^3\dot{x}}{(1+\frac{x^3}{y^2})^{3/2}y^4}-\frac{x^2\dot{x}}{(1+\frac{x^3}{y^2})^{3/2}y^3}+\frac{x^2\dot{y}}{(1+\frac{x^3}{y^2})^{3/2}y^3} &amp;
 \frac{1}{\sqrt{1+\frac{x^2}{y^2}}}
\end{bmatrix}
\end{align}\]
<h3 class='section_entry' id='model3'>1.5.  Model 3. Extended Kalman filter with constant acceleration kinematic model</h3>
<p>We augment <a href='#model2'>Model 2</a> above to include acceleration in the state, that is, </p>
\[\begin{align}
s = \begin{bmatrix} x \\ \dot{x} \\ \ddot{x} \\ y \\ \dot{y} \\ \ddot{y} \end{bmatrix},
A = \begin{bmatrix}
    1 &amp; T &amp; \frac{T^2}{2} &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; T &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; T &amp; \frac{T^2}{2} \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; T \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}
\end{align}\]
<p>The measurement model is still described by \eqref{eq:c_fxn}; however, the Jacobian linearization now becomes </p>
\[\begin{align}
\mathbf{J}_c = \begin{bmatrix}
 \frac{x}{\sqrt{x^2+y^2}} &amp; 0 &amp; 0 &amp; \frac{y}{\sqrt{x^2+y^2}} &amp; 0 &amp; 0 \\
 -\frac{1}{(1+\frac{x^2}{y^2})y} &amp; 0 &amp; 0 &amp; \frac{x}{(1+\frac{x^2}{y^2})y^2} &amp; 0 &amp; 0 \\
 -\frac{x^2\dot{x}}{(1+\frac{x^3}{y^2})^{3/2}y^3} + \frac{\dot{x}}{\sqrt{1+\frac{x^2}{y^2}}y} - \frac{x\dot{y}}{(1+\frac{x^3}{y^2})^{3/2}y^2} &amp;
 \frac{x}{\sqrt{1+\frac{x^2}{y^2}}y} &amp; 0 &amp;
 \frac{x^3\dot{x}}{(1+\frac{x^3}{y^2})^{3/2}y^4}-\frac{x^2\dot{x}}{(1+\frac{x^3}{y^2})^{3/2}y^3}+\frac{x^2\dot{y}}{(1+\frac{x^3}{y^2})^{3/2}y^3} &amp;
 \frac{1}{\sqrt{1+\frac{x^2}{y^2}}} &amp; 0
\end{bmatrix}
\end{align}\]
<h3 class='section_entry' id='1.6.'>1.6. Implementation results and to-do's</h3>
<ol>
<li><p>With <a href='#model1'>Model 1</a>, velocity estimation is consistently poor or slow to catch up with ground truth. Either tune covariance matrices, or implement extended Kalman filter to see whether the measurement model is the root cause. </p>
<li><p>How to evaluate and compare models or filters? </p>
<li><p>With <a href='#model3'>Model 3</a>, the filter is unstable, seemingly because acceleration estimates swing wildly for a few time periods before it converges, by which time position estimation may have become irrecoverably wrong. Is the solution a better tuned covariance \(Q\) or to relate acceleration with measurement, i.e. modify \eqref{eq:c_fxn}. </p>
<li><p>Visualize covariance, start with point cloud of \(\{r, \theta, \dot{r}\}\) using \(\{\sigma_r, \sigma_\theta, \sigma_\dot{r}\}\), coordinate transform to \(\{x, y, r\dot{r}\}\) or \(\{x, \dot{x}, \ddot{x}, y, \dot{y}, \ddot{y}\}\). </p>

</ol>


<script type="text/javascript">
// Fill in contents.
var c = document.getElementById("contents");
var elements = document.getElementsByClassName('section_entry');
if (c && elements) {
  var html = '<h2>Contents</h2>';
  for (var i = 0; i < elements.length; i++) {
    html += '<div class="contents_line_' +
            elements[i].nodeName +
            '"><a href="#' +
            elements[i].id + '">' + elements[i].innerHTML +
            '</a></div>';
  }
  c.innerHTML = html;
}

// Set title.
document.getElementById("title").innerHTML = __the_title__;
</script>

</body>
</html>
